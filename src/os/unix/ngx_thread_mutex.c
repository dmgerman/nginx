begin_unit|revision:1.0.0;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) Igor Sysoev  * Copyright (C) Nginx, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<ngx_config.h>
end_include

begin_include
include|#
directive|include
file|<ngx_core.h>
end_include

begin_comment
comment|/*  * All modern pthread mutex implementations try to acquire a lock  * atomically in userland before going to sleep in kernel.  Some  * spins before the sleeping.  *  * In Solaris since version 8 all mutex types spin before sleeping.  * The default spin count is 1000.  It can be overridden using  * _THREAD_ADAPTIVE_SPIN=100 environment variable.  *  * In MacOSX all mutex types spin to acquire a lock protecting a mutex's  * internals.  If the mutex is busy, thread calls Mach semaphore_wait().  *  *  * PTHREAD_MUTEX_NORMAL lacks deadlock detection and is the fastest  * mutex type.  *  *   Linux:    No spinning.  The internal name PTHREAD_MUTEX_TIMED_NP  *             remains from the times when pthread_mutex_timedlock() was  *             non-standard extension.  Alias name: PTHREAD_MUTEX_FAST_NP.  *   FreeBSD:  No spinning.  *  *  * PTHREAD_MUTEX_ERRORCHECK is usually as fast as PTHREAD_MUTEX_NORMAL  * yet has lightweight deadlock detection.  *  *   Linux:    No spinning.  The internal name: PTHREAD_MUTEX_ERRORCHECK_NP.  *   FreeBSD:  No spinning.  *  *  * PTHREAD_MUTEX_RECURSIVE allows recursive locking.  *  *   Linux:    No spinning.  The internal name: PTHREAD_MUTEX_RECURSIVE_NP.  *   FreeBSD:  No spinning.  *  *  * PTHREAD_MUTEX_ADAPTIVE_NP spins on SMP systems before sleeping.  *  *   Linux:    No deadlock detection.  Dynamically changes a spin count  *             for each mutex from 10 to 100 based on spin count taken  *             previously.  *   FreeBSD:  Deadlock detection.  The default spin count is 2000.  *             It can be overridden using LIBPTHREAD_SPINLOOPS environment  *             variable or by pthread_mutex_setspinloops_np().  If a lock  *             is still busy, sched_yield() can be called on both UP and  *             SMP systems.  The default yield loop count is zero, but  *             it can be set by LIBPTHREAD_YIELDLOOPS environment  *             variable or by pthread_mutex_setyieldloops_np().  *   Solaris:  No PTHREAD_MUTEX_ADAPTIVE_NP.  *   MacOSX:   No PTHREAD_MUTEX_ADAPTIVE_NP.  *  *  * PTHREAD_MUTEX_ELISION_NP is a Linux extension to elide locks using  * Intel Restricted Transactional Memory.  It is the most suitable for  * rwlock pattern access because it allows simultaneous reads without lock.  * Supported since glibc 2.18.  *  *  * PTHREAD_MUTEX_DEFAULT is default mutex type.  *  *   Linux:    PTHREAD_MUTEX_NORMAL.  *   FreeBSD:  PTHREAD_MUTEX_ERRORCHECK.  *   Solaris:  PTHREAD_MUTEX_NORMAL.  *   MacOSX:   PTHREAD_MUTEX_NORMAL.  */
end_comment

begin_function
name|ngx_int_t
DECL|function|ngx_thread_mutex_create (ngx_thread_mutex_t * mtx,ngx_log_t * log)
name|ngx_thread_mutex_create
parameter_list|(
name|ngx_thread_mutex_t
modifier|*
name|mtx
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_err_t
name|err
decl_stmt|;
name|pthread_mutexattr_t
name|attr
decl_stmt|;
name|err
operator|=
name|pthread_mutexattr_init
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_EMERG
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutexattr_init() failed"
argument_list|)
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
name|err
operator|=
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|attr
argument_list|,
name|PTHREAD_MUTEX_ERRORCHECK
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_EMERG
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutexattr_settype"
literal|"(PTHREAD_MUTEX_ERRORCHECK) failed"
argument_list|)
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
name|err
operator|=
name|pthread_mutex_init
argument_list|(
name|mtx
argument_list|,
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_EMERG
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutex_init() failed"
argument_list|)
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
name|err
operator|=
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutexattr_destroy() failed"
argument_list|)
expr_stmt|;
block|}
return|return
name|NGX_OK
return|;
block|}
end_function

begin_function
name|ngx_int_t
DECL|function|ngx_thread_mutex_destroy (ngx_thread_mutex_t * mtx,ngx_log_t * log)
name|ngx_thread_mutex_destroy
parameter_list|(
name|ngx_thread_mutex_t
modifier|*
name|mtx
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_err_t
name|err
decl_stmt|;
name|err
operator|=
name|pthread_mutex_destroy
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutex_destroy() failed"
argument_list|)
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
return|return
name|NGX_OK
return|;
block|}
end_function

begin_function
name|ngx_int_t
DECL|function|ngx_thread_mutex_lock (ngx_thread_mutex_t * mtx,ngx_log_t * log)
name|ngx_thread_mutex_lock
parameter_list|(
name|ngx_thread_mutex_t
modifier|*
name|mtx
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_err_t
name|err
decl_stmt|;
name|err
operator|=
name|pthread_mutex_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
return|return
name|NGX_OK
return|;
block|}
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutex_lock() failed"
argument_list|)
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
end_function

begin_function
name|ngx_int_t
DECL|function|ngx_thread_mutex_unlock (ngx_thread_mutex_t * mtx,ngx_log_t * log)
name|ngx_thread_mutex_unlock
parameter_list|(
name|ngx_thread_mutex_t
modifier|*
name|mtx
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_err_t
name|err
decl_stmt|;
name|err
operator|=
name|pthread_mutex_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block_content|ngx_time_update();
endif|#
directive|endif
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
return|return
name|NGX_OK
return|;
block|}
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|err
argument_list|,
literal|"pthread_mutex_unlock() failed"
argument_list|)
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
end_function

end_unit


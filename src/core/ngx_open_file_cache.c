begin_unit|revision:1.0.0;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) Igor Sysoev  * Copyright (C) Nginx, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<ngx_config.h>
end_include

begin_include
include|#
directive|include
file|<ngx_core.h>
end_include

begin_include
include|#
directive|include
file|<ngx_event.h>
end_include

begin_comment
comment|/*  * open file cache caches  *    open file handles with stat() info;  *    directories stat() info;  *    files and directories errors: not found, access denied, etc.  */
end_comment

begin_define
DECL|macro|NGX_MIN_READ_AHEAD
define|#
directive|define
name|NGX_MIN_READ_AHEAD
value|(128 * 1024)
end_define

begin_function_decl
specifier|static
name|void
name|ngx_open_file_cache_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|(
name|NGX_HAVE_OPENAT
operator|)
end_if

begin_function_decl
specifier|static
name|ngx_fd_t
name|ngx_openat_file_owner
parameter_list|(
name|ngx_fd_t
name|at_fd
parameter_list|,
specifier|const
name|u_char
modifier|*
name|name
parameter_list|,
name|ngx_int_t
name|mode
parameter_list|,
name|ngx_int_t
name|create
parameter_list|,
name|ngx_int_t
name|access
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|(
name|NGX_HAVE_O_PATH
operator|)
end_if

begin_function_decl
specifier|static
name|ngx_int_t
name|ngx_file_o_path_info
parameter_list|(
name|ngx_fd_t
name|fd
parameter_list|,
name|ngx_file_info_t
modifier|*
name|fi
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ngx_fd_t
name|ngx_open_file_wrapper
parameter_list|(
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_int_t
name|mode
parameter_list|,
name|ngx_int_t
name|create
parameter_list|,
name|ngx_int_t
name|access
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ngx_int_t
name|ngx_file_info_wrapper
parameter_list|(
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_file_info_t
modifier|*
name|fi
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ngx_int_t
name|ngx_open_and_stat_file
parameter_list|(
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_open_file_add_event
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_cached_open_file_t
modifier|*
name|file
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_open_file_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_close_cached_file
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_cached_open_file_t
modifier|*
name|file
parameter_list|,
name|ngx_uint_t
name|min_uses
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_open_file_del_event
parameter_list|(
name|ngx_cached_open_file_t
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_expire_old_cached_files
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_uint_t
name|n
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_open_file_cache_rbtree_insert_value
parameter_list|(
name|ngx_rbtree_node_t
modifier|*
name|temp
parameter_list|,
name|ngx_rbtree_node_t
modifier|*
name|node
parameter_list|,
name|ngx_rbtree_node_t
modifier|*
name|sentinel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ngx_cached_open_file_t
modifier|*
name|ngx_open_file_lookup
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngx_open_file_cache_remove
parameter_list|(
name|ngx_event_t
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|ngx_open_file_cache_t
modifier|*
DECL|function|ngx_open_file_cache_init (ngx_pool_t * pool,ngx_uint_t max,time_t inactive)
name|ngx_open_file_cache_init
parameter_list|(
name|ngx_pool_t
modifier|*
name|pool
parameter_list|,
name|ngx_uint_t
name|max
parameter_list|,
name|time_t
name|inactive
parameter_list|)
block|{
name|ngx_pool_cleanup_t
modifier|*
name|cln
decl_stmt|;
name|ngx_open_file_cache_t
modifier|*
name|cache
decl_stmt|;
name|cache
operator|=
name|ngx_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|ngx_open_file_cache_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|ngx_rbtree_init
argument_list|(
operator|&
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|cache
operator|->
name|sentinel
argument_list|,
name|ngx_open_file_cache_rbtree_insert_value
argument_list|)
expr_stmt|;
name|ngx_queue_init
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|)
expr_stmt|;
name|cache
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|max
operator|=
name|max
expr_stmt|;
name|cache
operator|->
name|inactive
operator|=
name|inactive
expr_stmt|;
name|cln
operator|=
name|ngx_pool_cleanup_add
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cln
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|cln
operator|->
name|handler
operator|=
name|ngx_open_file_cache_cleanup
expr_stmt|;
name|cln
operator|->
name|data
operator|=
name|cache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_open_file_cache_cleanup (void * data)
name|ngx_open_file_cache_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|ngx_open_file_cache_t
modifier|*
name|cache
init|=
name|data
decl_stmt|;
name|ngx_queue_t
modifier|*
name|q
decl_stmt|;
name|ngx_cached_open_file_t
modifier|*
name|file
decl_stmt|;
name|ngx_log_debug0
argument_list|(
name|NGX_LOG_DEBUG_CORE
argument_list|,
name|ngx_cycle
operator|->
name|log
argument_list|,
literal|0
argument_list|,
literal|"open file cache cleanup"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ngx_queue_empty
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|)
condition|)
block|{
break|break;
block|}
name|q
operator|=
name|ngx_queue_last
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|)
expr_stmt|;
name|file
operator|=
name|ngx_queue_data
argument_list|(
name|q
argument_list|,
name|ngx_cached_open_file_t
argument_list|,
name|queue
argument_list|)
expr_stmt|;
name|ngx_queue_remove
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ngx_rbtree_delete
argument_list|(
operator|&
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|file
operator|->
name|node
argument_list|)
expr_stmt|;
name|cache
operator|->
name|current
operator|--
expr_stmt|;
name|ngx_log_debug1
argument_list|(
name|NGX_LOG_DEBUG_CORE
argument_list|,
name|ngx_cycle
operator|->
name|log
argument_list|,
literal|0
argument_list|,
literal|"delete cached open file: %s"
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|err
operator|&&
operator|!
name|file
operator|->
name|is_dir
condition|)
block|{
name|file
operator|->
name|close
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|ngx_close_cached_file
argument_list|(
name|cache
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|ngx_cycle
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ngx_free
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cache
operator|->
name|current
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|ngx_cycle
operator|->
name|log
argument_list|,
literal|0
argument_list|,
literal|"%ui items still leave in open file cache"
argument_list|,
name|cache
operator|->
name|current
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache
operator|->
name|rbtree
operator|.
name|root
operator|!=
name|cache
operator|->
name|rbtree
operator|.
name|sentinel
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|ngx_cycle
operator|->
name|log
argument_list|,
literal|0
argument_list|,
literal|"rbtree still is not empty in open file cache"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|ngx_int_t
DECL|function|ngx_open_cached_file (ngx_open_file_cache_t * cache,ngx_str_t * name,ngx_open_file_info_t * of,ngx_pool_t * pool)
name|ngx_open_cached_file
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|ngx_int_t
name|rc
decl_stmt|;
name|ngx_file_info_t
name|fi
decl_stmt|;
name|ngx_pool_cleanup_t
modifier|*
name|cln
decl_stmt|;
name|ngx_cached_open_file_t
modifier|*
name|file
decl_stmt|;
name|ngx_pool_cleanup_file_t
modifier|*
name|clnf
decl_stmt|;
name|ngx_open_file_cache_cleanup_t
modifier|*
name|ofcln
decl_stmt|;
name|of
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
name|of
operator|->
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cache
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|of
operator|->
name|test_only
condition|)
block|{
if|if
condition|(
name|ngx_file_info_wrapper
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
operator|&
name|fi
argument_list|,
name|pool
operator|->
name|log
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
return|return
name|NGX_ERROR
return|;
block|}
name|of
operator|->
name|uniq
operator|=
name|ngx_file_uniq
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|mtime
operator|=
name|ngx_file_mtime
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|size
operator|=
name|ngx_file_size
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|fs_size
operator|=
name|ngx_file_fs_size
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_dir
operator|=
name|ngx_is_dir
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_file
operator|=
name|ngx_is_file
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_link
operator|=
name|ngx_is_link
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_exec
operator|=
name|ngx_is_exec
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
return|return
name|NGX_OK
return|;
block|}
name|cln
operator|=
name|ngx_pool_cleanup_add
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|ngx_pool_cleanup_file_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cln
operator|==
name|NULL
condition|)
block|{
return|return
name|NGX_ERROR
return|;
block|}
name|rc
operator|=
name|ngx_open_and_stat_file
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|NGX_OK
operator|&&
operator|!
name|of
operator|->
name|is_dir
condition|)
block|{
name|cln
operator|->
name|handler
operator|=
name|ngx_pool_cleanup_file
expr_stmt|;
name|clnf
operator|=
name|cln
operator|->
name|data
expr_stmt|;
name|clnf
operator|->
name|fd
operator|=
name|of
operator|->
name|fd
expr_stmt|;
name|clnf
operator|->
name|name
operator|=
name|name
operator|->
name|data
expr_stmt|;
name|clnf
operator|->
name|log
operator|=
name|pool
operator|->
name|log
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
name|cln
operator|=
name|ngx_pool_cleanup_add
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|ngx_open_file_cache_cleanup_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cln
operator|==
name|NULL
condition|)
block|{
return|return
name|NGX_ERROR
return|;
block|}
name|now
operator|=
name|ngx_time
argument_list|()
expr_stmt|;
name|hash
operator|=
name|ngx_crc32_long
argument_list|(
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
argument_list|)
expr_stmt|;
name|file
operator|=
name|ngx_open_file_lookup
argument_list|(
name|cache
argument_list|,
name|name
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
block|{
name|file
operator|->
name|uses
operator|++
expr_stmt|;
name|ngx_queue_remove
argument_list|(
operator|&
name|file
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|fd
operator|==
name|NGX_INVALID_FILE
operator|&&
name|file
operator|->
name|err
operator|==
literal|0
operator|&&
operator|!
name|file
operator|->
name|is_dir
condition|)
block|{
comment|/* file was not used often enough to keep open */
name|rc
operator|=
name|ngx_open_and_stat_file
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|NGX_OK
operator|&&
operator|(
name|of
operator|->
name|err
operator|==
literal|0
operator|||
operator|!
name|of
operator|->
name|errors
operator|)
condition|)
block|{
goto|goto
name|failed
goto|;
block|}
goto|goto
name|add_event
goto|;
block|}
if|if
condition|(
name|file
operator|->
name|use_event
operator|||
operator|(
name|file
operator|->
name|event
operator|==
name|NULL
operator|&&
operator|(
name|of
operator|->
name|uniq
operator|==
literal|0
operator|||
name|of
operator|->
name|uniq
operator|==
name|file
operator|->
name|uniq
operator|)
operator|&&
name|now
operator|-
name|file
operator|->
name|created
operator|<
name|of
operator|->
name|valid
if|#
directive|if
operator|(
name|NGX_HAVE_OPENAT
operator|)
operator|&&
name|of
operator|->
name|disable_symlinks
operator|==
name|file
operator|->
name|disable_symlinks
operator|&&
name|of
operator|->
name|disable_symlinks_from
operator|==
name|file
operator|->
name|disable_symlinks_from
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|file
operator|->
name|err
operator|==
literal|0
condition|)
block|{
name|of
operator|->
name|fd
operator|=
name|file
operator|->
name|fd
expr_stmt|;
name|of
operator|->
name|uniq
operator|=
name|file
operator|->
name|uniq
expr_stmt|;
name|of
operator|->
name|mtime
operator|=
name|file
operator|->
name|mtime
expr_stmt|;
name|of
operator|->
name|size
operator|=
name|file
operator|->
name|size
expr_stmt|;
name|of
operator|->
name|is_dir
operator|=
name|file
operator|->
name|is_dir
expr_stmt|;
name|of
operator|->
name|is_file
operator|=
name|file
operator|->
name|is_file
expr_stmt|;
name|of
operator|->
name|is_link
operator|=
name|file
operator|->
name|is_link
expr_stmt|;
name|of
operator|->
name|is_exec
operator|=
name|file
operator|->
name|is_exec
expr_stmt|;
name|of
operator|->
name|is_directio
operator|=
name|file
operator|->
name|is_directio
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|is_dir
condition|)
block|{
name|file
operator|->
name|count
operator|++
expr_stmt|;
name|ngx_open_file_add_event
argument_list|(
name|cache
argument_list|,
name|file
argument_list|,
name|of
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|of
operator|->
name|err
operator|=
name|file
operator|->
name|err
expr_stmt|;
if|#
directive|if
operator|(
name|NGX_HAVE_OPENAT
operator|)
name|of
operator|->
name|failed
operator|=
name|file
operator|->
name|disable_symlinks
condition|?
name|ngx_openat_file_n
else|:
name|ngx_open_file_n
expr_stmt|;
else|#
directive|else
name|of
operator|->
name|failed
operator|=
name|ngx_open_file_n
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|found
goto|;
block|}
name|ngx_log_debug4
argument_list|(
name|NGX_LOG_DEBUG_CORE
argument_list|,
name|pool
operator|->
name|log
argument_list|,
literal|0
argument_list|,
literal|"retest open file: %s, fd:%d, c:%d, e:%d"
argument_list|,
name|file
operator|->
name|name
argument_list|,
name|file
operator|->
name|fd
argument_list|,
name|file
operator|->
name|count
argument_list|,
name|file
operator|->
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|is_dir
condition|)
block|{
comment|/*              * chances that directory became file are very small              * so test_dir flag allows to use a single syscall              * in ngx_file_info() instead of three syscalls              */
name|of
operator|->
name|test_dir
operator|=
literal|1
expr_stmt|;
block|}
name|of
operator|->
name|fd
operator|=
name|file
operator|->
name|fd
expr_stmt|;
name|of
operator|->
name|uniq
operator|=
name|file
operator|->
name|uniq
expr_stmt|;
name|rc
operator|=
name|ngx_open_and_stat_file
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|NGX_OK
operator|&&
operator|(
name|of
operator|->
name|err
operator|==
literal|0
operator|||
operator|!
name|of
operator|->
name|errors
operator|)
condition|)
block|{
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|of
operator|->
name|is_dir
condition|)
block|{
if|if
condition|(
name|file
operator|->
name|is_dir
operator|||
name|file
operator|->
name|err
condition|)
block|{
goto|goto
name|update
goto|;
block|}
comment|/* file became directory */
block|}
if|else if
condition|(
name|of
operator|->
name|err
operator|==
literal|0
condition|)
block|{
comment|/* file */
if|if
condition|(
name|file
operator|->
name|is_dir
operator|||
name|file
operator|->
name|err
condition|)
block|{
goto|goto
name|add_event
goto|;
block|}
if|if
condition|(
name|of
operator|->
name|uniq
operator|==
name|file
operator|->
name|uniq
condition|)
block|{
if|if
condition|(
name|file
operator|->
name|event
condition|)
block|{
name|file
operator|->
name|use_event
operator|=
literal|1
expr_stmt|;
block|}
name|of
operator|->
name|is_directio
operator|=
name|file
operator|->
name|is_directio
expr_stmt|;
goto|goto
name|update
goto|;
block|}
comment|/* file was changed */
block|}
else|else
block|{
comment|/* error to cache */
if|if
condition|(
name|file
operator|->
name|err
operator|||
name|file
operator|->
name|is_dir
condition|)
block|{
goto|goto
name|update
goto|;
block|}
comment|/* file was removed, etc. */
block|}
if|if
condition|(
name|file
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|ngx_open_file_del_event
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngx_close_file
argument_list|(
name|file
operator|->
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|pool
operator|->
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
goto|goto
name|add_event
goto|;
block|}
name|ngx_rbtree_delete
argument_list|(
operator|&
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|file
operator|->
name|node
argument_list|)
expr_stmt|;
name|cache
operator|->
name|current
operator|--
expr_stmt|;
name|file
operator|->
name|close
operator|=
literal|1
expr_stmt|;
goto|goto
name|create
goto|;
block|}
comment|/* not found */
name|rc
operator|=
name|ngx_open_and_stat_file
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
name|NGX_OK
operator|&&
operator|(
name|of
operator|->
name|err
operator|==
literal|0
operator|||
operator|!
name|of
operator|->
name|errors
operator|)
condition|)
block|{
goto|goto
name|failed
goto|;
block|}
name|create
label|:
if|if
condition|(
name|cache
operator|->
name|current
operator|>=
name|cache
operator|->
name|max
condition|)
block|{
name|ngx_expire_old_cached_files
argument_list|(
name|cache
argument_list|,
literal|0
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
name|file
operator|=
name|ngx_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ngx_cached_open_file_t
argument_list|)
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed
goto|;
block|}
name|file
operator|->
name|name
operator|=
name|ngx_alloc
argument_list|(
name|name
operator|->
name|len
operator|+
literal|1
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|ngx_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|file
operator|=
name|NULL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|ngx_cpystrn
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|name
operator|->
name|data
argument_list|,
name|name
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|file
operator|->
name|node
operator|.
name|key
operator|=
name|hash
expr_stmt|;
name|ngx_rbtree_insert
argument_list|(
operator|&
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|file
operator|->
name|node
argument_list|)
expr_stmt|;
name|cache
operator|->
name|current
operator|++
expr_stmt|;
name|file
operator|->
name|uses
operator|=
literal|1
expr_stmt|;
name|file
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|use_event
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|event
operator|=
name|NULL
expr_stmt|;
name|add_event
label|:
name|ngx_open_file_add_event
argument_list|(
name|cache
argument_list|,
name|file
argument_list|,
name|of
argument_list|,
name|pool
operator|->
name|log
argument_list|)
expr_stmt|;
name|update
label|:
name|file
operator|->
name|fd
operator|=
name|of
operator|->
name|fd
expr_stmt|;
name|file
operator|->
name|err
operator|=
name|of
operator|->
name|err
expr_stmt|;
if|#
directive|if
operator|(
name|NGX_HAVE_OPENAT
operator|)
name|file
operator|->
name|disable_symlinks
operator|=
name|of
operator|->
name|disable_symlinks
expr_stmt|;
name|file
operator|->
name|disable_symlinks_from
operator|=
name|of
operator|->
name|disable_symlinks_from
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|of
operator|->
name|err
operator|==
literal|0
condition|)
block|{
name|file
operator|->
name|uniq
operator|=
name|of
operator|->
name|uniq
expr_stmt|;
name|file
operator|->
name|mtime
operator|=
name|of
operator|->
name|mtime
expr_stmt|;
name|file
operator|->
name|size
operator|=
name|of
operator|->
name|size
expr_stmt|;
name|file
operator|->
name|close
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|is_dir
operator|=
name|of
operator|->
name|is_dir
expr_stmt|;
name|file
operator|->
name|is_file
operator|=
name|of
operator|->
name|is_file
expr_stmt|;
name|file
operator|->
name|is_link
operator|=
name|of
operator|->
name|is_link
expr_stmt|;
name|file
operator|->
name|is_exec
operator|=
name|of
operator|->
name|is_exec
expr_stmt|;
name|file
operator|->
name|is_directio
operator|=
name|of
operator|->
name|is_directio
expr_stmt|;
if|if
condition|(
operator|!
name|of
operator|->
name|is_dir
condition|)
block|{
name|file
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
name|file
operator|->
name|created
operator|=
name|now
expr_stmt|;
name|found
label|:
name|file
operator|->
name|accessed
operator|=
name|now
expr_stmt|;
name|ngx_queue_insert_head
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|,
operator|&
name|file
operator|->
name|queue
argument_list|)
expr_stmt|;
name|ngx_log_debug5
argument_list|(
name|NGX_LOG_DEBUG_CORE
argument_list|,
name|pool
operator|->
name|log
argument_list|,
literal|0
argument_list|,
literal|"cached open file: %s, fd:%d, c:%d, e:%d, u:%d"
argument_list|,
name|file
operator|->
name|name
argument_list|,
name|file
operator|->
name|fd
argument_list|,
name|file
operator|->
name|count
argument_list|,
name|file
operator|->
name|err
argument_list|,
name|file
operator|->
name|uses
argument_list|)
expr_stmt|;
if|if
condition|(
name|of
operator|->
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|of
operator|->
name|is_dir
condition|)
block|{
name|cln
operator|->
name|handler
operator|=
name|ngx_open_file_cleanup
expr_stmt|;
name|ofcln
operator|=
name|cln
operator|->
name|data
expr_stmt|;
name|ofcln
operator|->
name|cache
operator|=
name|cache
expr_stmt|;
name|ofcln
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|ofcln
operator|->
name|min_uses
operator|=
name|of
operator|->
name|min_uses
expr_stmt|;
name|ofcln
operator|->
name|log
operator|=
name|pool
operator|->
name|log
expr_stmt|;
block|}
return|return
name|NGX_OK
return|;
block|}
return|return
name|NGX_ERROR
return|;
name|failed
label|:
if|if
condition|(
name|file
condition|)
block|{
name|ngx_rbtree_delete
argument_list|(
operator|&
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|file
operator|->
name|node
argument_list|)
expr_stmt|;
name|cache
operator|->
name|current
operator|--
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|file
operator|->
name|fd
operator|!=
name|NGX_INVALID_FILE
condition|)
block|{
if|if
condition|(
name|ngx_close_file
argument_list|(
name|file
operator|->
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|pool
operator|->
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%s\" failed"
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|ngx_free
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|file
operator|->
name|close
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|of
operator|->
name|fd
operator|!=
name|NGX_INVALID_FILE
condition|)
block|{
if|if
condition|(
name|ngx_close_file
argument_list|(
name|of
operator|->
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|pool
operator|->
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NGX_ERROR
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|NGX_HAVE_OPENAT
operator|)
end_if

begin_function
specifier|static
name|ngx_fd_t
DECL|function|ngx_openat_file_owner (ngx_fd_t at_fd,const u_char * name,ngx_int_t mode,ngx_int_t create,ngx_int_t access,ngx_log_t * log)
name|ngx_openat_file_owner
parameter_list|(
name|ngx_fd_t
name|at_fd
parameter_list|,
specifier|const
name|u_char
modifier|*
name|name
parameter_list|,
name|ngx_int_t
name|mode
parameter_list|,
name|ngx_int_t
name|create
parameter_list|,
name|ngx_int_t
name|access
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_fd_t
name|fd
decl_stmt|;
name|ngx_err_t
name|err
decl_stmt|;
name|ngx_file_info_t
name|fi
decl_stmt|,
name|atfi
decl_stmt|;
comment|/*      * To allow symlinks with the same owner, use openat() (followed      * by fstat()) and fstatat(AT_SYMLINK_NOFOLLOW), and then compare      * uids between fstat() and fstatat().      *      * As there is a race between openat() and fstatat() we don't      * know if openat() in fact opened symlink or not.  Therefore,      * we have to compare uids even if fstatat() reports the opened      * component isn't a symlink (as we don't know whether it was      * symlink during openat() or not).      */
name|fd
operator|=
name|ngx_openat_file
argument_list|(
name|at_fd
argument_list|,
name|name
argument_list|,
name|mode
argument_list|,
name|create
argument_list|,
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
return|return
name|NGX_INVALID_FILE
return|;
block|}
if|if
condition|(
name|ngx_file_at_info
argument_list|(
name|at_fd
argument_list|,
name|name
argument_list|,
operator|&
name|atfi
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|err
operator|=
name|ngx_errno
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|#
directive|if
operator|(
name|NGX_HAVE_O_PATH
operator|)
if|if
condition|(
name|ngx_file_o_path_info
argument_list|(
name|fd
argument_list|,
operator|&
name|fi
argument_list|,
name|log
argument_list|)
operator|==
name|NGX_ERROR
condition|)
block|{
name|err
operator|=
name|ngx_errno
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
else|#
directive|else
if|if
condition|(
name|ngx_fd_info
argument_list|(
name|fd
argument_list|,
operator|&
name|fi
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|err
operator|=
name|ngx_errno
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fi
operator|.
name|st_uid
operator|!=
name|atfi
operator|.
name|st_uid
condition|)
block|{
name|err
operator|=
name|NGX_ELOOP
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
return|return
name|fd
return|;
name|failed
label|:
if|if
condition|(
name|ngx_close_file
argument_list|(
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|ngx_set_errno
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|NGX_INVALID_FILE
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|NGX_HAVE_O_PATH
operator|)
end_if

begin_function
specifier|static
name|ngx_int_t
DECL|function|ngx_file_o_path_info (ngx_fd_t fd,ngx_file_info_t * fi,ngx_log_t * log)
name|ngx_file_o_path_info
parameter_list|(
name|ngx_fd_t
name|fd
parameter_list|,
name|ngx_file_info_t
modifier|*
name|fi
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
specifier|static
name|ngx_uint_t
name|use_fstat
init|=
literal|1
decl_stmt|;
comment|/*      * In Linux 2.6.39 the O_PATH flag was introduced that allows to obtain      * a descriptor without actually opening file or directory.  It requires      * less permissions for path components, but till Linux 3.6 fstat() returns      * EBADF on such descriptors, and fstatat() with the AT_EMPTY_PATH flag      * should be used instead.      *      * Three scenarios are handled in this function:      *      * 1) The kernel is newer than 3.6 or fstat() with O_PATH support was      *    backported by vendor.  Then fstat() is used.      *      * 2) The kernel is newer than 2.6.39 but older than 3.6.  In this case      *    the first call of fstat() returns EBADF and we fallback to fstatat()      *    with AT_EMPTY_PATH which was introduced at the same time as O_PATH.      *      * 3) The kernel is older than 2.6.39 but nginx was build with O_PATH      *    support.  Since descriptors are opened with O_PATH|O_RDONLY flags      *    and O_PATH is ignored by the kernel then the O_RDONLY flag is      *    actually used.  In this case fstat() just works.      */
if|if
condition|(
name|use_fstat
condition|)
block|{
if|if
condition|(
name|ngx_fd_info
argument_list|(
name|fd
argument_list|,
name|fi
argument_list|)
operator|!=
name|NGX_FILE_ERROR
condition|)
block|{
return|return
name|NGX_OK
return|;
block|}
if|if
condition|(
name|ngx_errno
operator|!=
name|NGX_EBADF
condition|)
block|{
return|return
name|NGX_ERROR
return|;
block|}
name|ngx_log_error
argument_list|(
name|NGX_LOG_NOTICE
argument_list|,
name|log
argument_list|,
literal|0
argument_list|,
literal|"fstat(O_PATH) failed with EBADF, "
literal|"switching to fstatat(AT_EMPTY_PATH)"
argument_list|)
expr_stmt|;
name|use_fstat
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ngx_file_at_info
argument_list|(
name|fd
argument_list|,
literal|""
argument_list|,
name|fi
argument_list|,
name|AT_EMPTY_PATH
argument_list|)
operator|!=
name|NGX_FILE_ERROR
condition|)
block|{
return|return
name|NGX_OK
return|;
block|}
return|return
name|NGX_ERROR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NGX_HAVE_OPENAT */
end_comment

begin_function
specifier|static
name|ngx_fd_t
DECL|function|ngx_open_file_wrapper (ngx_str_t * name,ngx_open_file_info_t * of,ngx_int_t mode,ngx_int_t create,ngx_int_t access,ngx_log_t * log)
name|ngx_open_file_wrapper
parameter_list|(
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_int_t
name|mode
parameter_list|,
name|ngx_int_t
name|create
parameter_list|,
name|ngx_int_t
name|access
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_fd_t
name|fd
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|NGX_HAVE_OPENAT
operator|)
name|fd
operator|=
name|ngx_open_file
argument_list|(
name|name
operator|->
name|data
argument_list|,
name|mode
argument_list|,
name|create
argument_list|,
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_open_file_n
expr_stmt|;
return|return
name|NGX_INVALID_FILE
return|;
block|}
return|return
name|fd
return|;
else|#
directive|else
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|ngx_fd_t
name|at_fd
decl_stmt|;
name|ngx_str_t
name|at_name
decl_stmt|;
if|if
condition|(
name|of
operator|->
name|disable_symlinks
operator|==
name|NGX_DISABLE_SYMLINKS_OFF
condition|)
block|{
name|fd
operator|=
name|ngx_open_file
argument_list|(
name|name
operator|->
name|data
argument_list|,
name|mode
argument_list|,
name|create
argument_list|,
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_open_file_n
expr_stmt|;
return|return
name|NGX_INVALID_FILE
return|;
block|}
return|return
name|fd
return|;
block|}
name|p
operator|=
name|name
operator|->
name|data
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|name
operator|->
name|len
expr_stmt|;
name|at_name
operator|=
operator|*
name|name
expr_stmt|;
if|if
condition|(
name|of
operator|->
name|disable_symlinks_from
condition|)
block|{
name|cp
operator|=
name|p
operator|+
name|of
operator|->
name|disable_symlinks_from
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|at_fd
operator|=
name|ngx_open_file
argument_list|(
name|p
argument_list|,
name|NGX_FILE_SEARCH
operator||
name|NGX_FILE_NONBLOCK
argument_list|,
name|NGX_FILE_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|at_fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_open_file_n
expr_stmt|;
return|return
name|NGX_INVALID_FILE
return|;
block|}
name|at_name
operator|.
name|len
operator|=
name|of
operator|->
name|disable_symlinks_from
expr_stmt|;
name|p
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
if|else if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
name|at_fd
operator|=
name|ngx_open_file
argument_list|(
literal|"/"
argument_list|,
name|NGX_FILE_SEARCH
operator||
name|NGX_FILE_NONBLOCK
argument_list|,
name|NGX_FILE_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|at_fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_openat_file_n
expr_stmt|;
return|return
name|NGX_INVALID_FILE
return|;
block|}
name|at_name
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|at_fd
operator|=
name|NGX_AT_FDCWD
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|ngx_strlchr
argument_list|(
name|p
argument_list|,
name|end
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|cp
operator|==
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|of
operator|->
name|disable_symlinks
operator|==
name|NGX_DISABLE_SYMLINKS_NOTOWNER
condition|)
block|{
name|fd
operator|=
name|ngx_openat_file_owner
argument_list|(
name|at_fd
argument_list|,
name|p
argument_list|,
name|NGX_FILE_SEARCH
operator||
name|NGX_FILE_NONBLOCK
argument_list|,
name|NGX_FILE_OPEN
argument_list|,
literal|0
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|ngx_openat_file
argument_list|(
name|at_fd
argument_list|,
name|p
argument_list|,
name|NGX_FILE_SEARCH
operator||
name|NGX_FILE_NONBLOCK
operator||
name|NGX_FILE_NOFOLLOW
argument_list|,
name|NGX_FILE_OPEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_openat_file_n
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|at_fd
operator|!=
name|NGX_AT_FDCWD
operator|&&
name|ngx_close_file
argument_list|(
name|at_fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
operator|&
name|at_name
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|at_fd
operator|=
name|fd
expr_stmt|;
name|at_name
operator|.
name|len
operator|=
name|cp
operator|-
name|at_name
operator|.
name|data
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
comment|/*          * If pathname ends with a trailing slash, assume the last path          * component is a directory and reopen it with requested flags;          * if not, fail with ENOTDIR as per POSIX.          *          * We cannot rely on O_DIRECTORY in the loop above to check          * that the last path component is a directory because          * O_DIRECTORY doesn't work on FreeBSD 8.  Fortunately, by          * reopening a directory, we don't depend on it at all.          */
name|fd
operator|=
name|ngx_openat_file
argument_list|(
name|at_fd
argument_list|,
literal|"."
argument_list|,
name|mode
argument_list|,
name|create
argument_list|,
name|access
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|of
operator|->
name|disable_symlinks
operator|==
name|NGX_DISABLE_SYMLINKS_NOTOWNER
operator|&&
operator|!
operator|(
name|create
operator|&
operator|(
name|NGX_FILE_CREATE_OR_OPEN
operator||
name|NGX_FILE_TRUNCATE
operator|)
operator|)
condition|)
block|{
name|fd
operator|=
name|ngx_openat_file_owner
argument_list|(
name|at_fd
argument_list|,
name|p
argument_list|,
name|mode
argument_list|,
name|create
argument_list|,
name|access
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|ngx_openat_file
argument_list|(
name|at_fd
argument_list|,
name|p
argument_list|,
name|mode
operator||
name|NGX_FILE_NOFOLLOW
argument_list|,
name|create
argument_list|,
name|access
argument_list|)
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_openat_file_n
expr_stmt|;
block|}
name|failed
label|:
if|if
condition|(
name|at_fd
operator|!=
name|NGX_AT_FDCWD
operator|&&
name|ngx_close_file
argument_list|(
name|at_fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
operator|&
name|at_name
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|ngx_int_t
DECL|function|ngx_file_info_wrapper (ngx_str_t * name,ngx_open_file_info_t * of,ngx_file_info_t * fi,ngx_log_t * log)
name|ngx_file_info_wrapper
parameter_list|(
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_file_info_t
modifier|*
name|fi
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_int_t
name|rc
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|NGX_HAVE_OPENAT
operator|)
name|rc
operator|=
name|ngx_file_info
argument_list|(
name|name
operator|->
name|data
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_file_info_n
expr_stmt|;
return|return
name|NGX_FILE_ERROR
return|;
block|}
return|return
name|rc
return|;
else|#
directive|else
name|ngx_fd_t
name|fd
decl_stmt|;
if|if
condition|(
name|of
operator|->
name|disable_symlinks
operator|==
name|NGX_DISABLE_SYMLINKS_OFF
condition|)
block|{
name|rc
operator|=
name|ngx_file_info
argument_list|(
name|name
operator|->
name|data
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_file_info_n
expr_stmt|;
return|return
name|NGX_FILE_ERROR
return|;
block|}
return|return
name|rc
return|;
block|}
name|fd
operator|=
name|ngx_open_file_wrapper
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|NGX_FILE_RDONLY
operator||
name|NGX_FILE_NONBLOCK
argument_list|,
name|NGX_FILE_OPEN
argument_list|,
literal|0
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
return|return
name|NGX_FILE_ERROR
return|;
block|}
name|rc
operator|=
name|ngx_fd_info
argument_list|(
name|fd
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|of
operator|->
name|err
operator|=
name|ngx_errno
expr_stmt|;
name|of
operator|->
name|failed
operator|=
name|ngx_fd_info_n
expr_stmt|;
block|}
if|if
condition|(
name|ngx_close_file
argument_list|(
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|ngx_int_t
DECL|function|ngx_open_and_stat_file (ngx_str_t * name,ngx_open_file_info_t * of,ngx_log_t * log)
name|ngx_open_and_stat_file
parameter_list|(
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_fd_t
name|fd
decl_stmt|;
name|ngx_file_info_t
name|fi
decl_stmt|;
if|if
condition|(
name|of
operator|->
name|fd
operator|!=
name|NGX_INVALID_FILE
condition|)
block|{
if|if
condition|(
name|ngx_file_info_wrapper
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
operator|&
name|fi
argument_list|,
name|log
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|of
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
if|if
condition|(
name|of
operator|->
name|uniq
operator|==
name|ngx_file_uniq
argument_list|(
operator|&
name|fi
argument_list|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|else if
condition|(
name|of
operator|->
name|test_dir
condition|)
block|{
if|if
condition|(
name|ngx_file_info_wrapper
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
operator|&
name|fi
argument_list|,
name|log
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|of
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
if|if
condition|(
name|ngx_is_dir
argument_list|(
operator|&
name|fi
argument_list|)
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|of
operator|->
name|log
condition|)
block|{
comment|/*          * Use non-blocking open() not to hang on FIFO files, etc.          * This flag has no effect on a regular files.          */
name|fd
operator|=
name|ngx_open_file_wrapper
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|NGX_FILE_RDONLY
operator||
name|NGX_FILE_NONBLOCK
argument_list|,
name|NGX_FILE_OPEN
argument_list|,
literal|0
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|ngx_open_file_wrapper
argument_list|(
name|name
argument_list|,
name|of
argument_list|,
name|NGX_FILE_APPEND
argument_list|,
name|NGX_FILE_CREATE_OR_OPEN
argument_list|,
name|NGX_FILE_DEFAULT_ACCESS
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|==
name|NGX_INVALID_FILE
condition|)
block|{
name|of
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
if|if
condition|(
name|ngx_fd_info
argument_list|(
name|fd
argument_list|,
operator|&
name|fi
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_CRIT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_fd_info_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngx_close_file
argument_list|(
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|of
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
return|return
name|NGX_ERROR
return|;
block|}
if|if
condition|(
name|ngx_is_dir
argument_list|(
operator|&
name|fi
argument_list|)
condition|)
block|{
if|if
condition|(
name|ngx_close_file
argument_list|(
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|of
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
block|}
else|else
block|{
name|of
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|of
operator|->
name|read_ahead
operator|&&
name|ngx_file_size
argument_list|(
operator|&
name|fi
argument_list|)
operator|>
name|NGX_MIN_READ_AHEAD
condition|)
block|{
if|if
condition|(
name|ngx_read_ahead
argument_list|(
name|fd
argument_list|,
name|of
operator|->
name|read_ahead
argument_list|)
operator|==
name|NGX_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_read_ahead_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|of
operator|->
name|directio
operator|<=
name|ngx_file_size
argument_list|(
operator|&
name|fi
argument_list|)
condition|)
block|{
if|if
condition|(
name|ngx_directio_on
argument_list|(
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_directio_on_n
literal|" \"%V\" failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|of
operator|->
name|is_directio
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
name|of
operator|->
name|uniq
operator|=
name|ngx_file_uniq
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|mtime
operator|=
name|ngx_file_mtime
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|size
operator|=
name|ngx_file_size
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|fs_size
operator|=
name|ngx_file_fs_size
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_dir
operator|=
name|ngx_is_dir
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_file
operator|=
name|ngx_is_file
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_link
operator|=
name|ngx_is_link
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
name|of
operator|->
name|is_exec
operator|=
name|ngx_is_exec
argument_list|(
operator|&
name|fi
argument_list|)
expr_stmt|;
return|return
name|NGX_OK
return|;
block|}
end_function

begin_comment
comment|/*  * we ignore any possible event setting error and  * fallback to usual periodic file retests  */
end_comment

begin_function
specifier|static
name|void
DECL|function|ngx_open_file_add_event (ngx_open_file_cache_t * cache,ngx_cached_open_file_t * file,ngx_open_file_info_t * of,ngx_log_t * log)
name|ngx_open_file_add_event
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_cached_open_file_t
modifier|*
name|file
parameter_list|,
name|ngx_open_file_info_t
modifier|*
name|of
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_open_file_cache_event_t
modifier|*
name|fev
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ngx_event_flags
operator|&
name|NGX_USE_VNODE_EVENT
operator|)
operator|||
operator|!
name|of
operator|->
name|events
operator|||
name|file
operator|->
name|event
operator|||
name|of
operator|->
name|fd
operator|==
name|NGX_INVALID_FILE
operator|||
name|file
operator|->
name|uses
operator|<
name|of
operator|->
name|min_uses
condition|)
block|{
return|return;
block|}
name|file
operator|->
name|use_event
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|event
operator|=
name|ngx_calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ngx_event_t
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|event
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|fev
operator|=
name|ngx_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ngx_open_file_cache_event_t
argument_list|)
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|fev
operator|==
name|NULL
condition|)
block|{
name|ngx_free
argument_list|(
name|file
operator|->
name|event
argument_list|)
expr_stmt|;
name|file
operator|->
name|event
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|fev
operator|->
name|fd
operator|=
name|of
operator|->
name|fd
expr_stmt|;
name|fev
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|fev
operator|->
name|cache
operator|=
name|cache
expr_stmt|;
name|file
operator|->
name|event
operator|->
name|handler
operator|=
name|ngx_open_file_cache_remove
expr_stmt|;
name|file
operator|->
name|event
operator|->
name|data
operator|=
name|fev
expr_stmt|;
comment|/*      * although vnode event may be called while ngx_cycle->poll      * destruction, however, cleanup procedures are run before any      * memory freeing and events will be canceled.      */
name|file
operator|->
name|event
operator|->
name|log
operator|=
name|ngx_cycle
operator|->
name|log
expr_stmt|;
if|if
condition|(
name|ngx_add_event
argument_list|(
name|file
operator|->
name|event
argument_list|,
name|NGX_VNODE_EVENT
argument_list|,
name|NGX_ONESHOT_EVENT
argument_list|)
operator|!=
name|NGX_OK
condition|)
block|{
name|ngx_free
argument_list|(
name|file
operator|->
name|event
operator|->
name|data
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
operator|->
name|event
argument_list|)
expr_stmt|;
name|file
operator|->
name|event
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/*      * we do not set file->use_event here because there may be a race      * condition: a file may be deleted between opening the file and      * adding event, so we rely upon event notification only after      * one file revalidation on next file access      */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_open_file_cleanup (void * data)
name|ngx_open_file_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|ngx_open_file_cache_cleanup_t
modifier|*
name|c
init|=
name|data
decl_stmt|;
name|c
operator|->
name|file
operator|->
name|count
operator|--
expr_stmt|;
name|ngx_close_cached_file
argument_list|(
name|c
operator|->
name|cache
argument_list|,
name|c
operator|->
name|file
argument_list|,
name|c
operator|->
name|min_uses
argument_list|,
name|c
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* drop one or two expired open files */
name|ngx_expire_old_cached_files
argument_list|(
name|c
operator|->
name|cache
argument_list|,
literal|1
argument_list|,
name|c
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_close_cached_file (ngx_open_file_cache_t * cache,ngx_cached_open_file_t * file,ngx_uint_t min_uses,ngx_log_t * log)
name|ngx_close_cached_file
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_cached_open_file_t
modifier|*
name|file
parameter_list|,
name|ngx_uint_t
name|min_uses
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|ngx_log_debug5
argument_list|(
name|NGX_LOG_DEBUG_CORE
argument_list|,
name|log
argument_list|,
literal|0
argument_list|,
literal|"close cached open file: %s, fd:%d, c:%d, u:%d, %d"
argument_list|,
name|file
operator|->
name|name
argument_list|,
name|file
operator|->
name|fd
argument_list|,
name|file
operator|->
name|count
argument_list|,
name|file
operator|->
name|uses
argument_list|,
name|file
operator|->
name|close
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|close
condition|)
block|{
name|file
operator|->
name|accessed
operator|=
name|ngx_time
argument_list|()
expr_stmt|;
name|ngx_queue_remove
argument_list|(
operator|&
name|file
operator|->
name|queue
argument_list|)
expr_stmt|;
name|ngx_queue_insert_head
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|,
operator|&
name|file
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|uses
operator|>=
name|min_uses
operator|||
name|file
operator|->
name|count
condition|)
block|{
return|return;
block|}
block|}
name|ngx_open_file_del_event
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|count
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|file
operator|->
name|fd
operator|!=
name|NGX_INVALID_FILE
condition|)
block|{
if|if
condition|(
name|ngx_close_file
argument_list|(
name|file
operator|->
name|fd
argument_list|)
operator|==
name|NGX_FILE_ERROR
condition|)
block|{
name|ngx_log_error
argument_list|(
name|NGX_LOG_ALERT
argument_list|,
name|log
argument_list|,
name|ngx_errno
argument_list|,
name|ngx_close_file_n
literal|" \"%s\" failed"
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|file
operator|->
name|fd
operator|=
name|NGX_INVALID_FILE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file
operator|->
name|close
condition|)
block|{
return|return;
block|}
name|ngx_free
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_open_file_del_event (ngx_cached_open_file_t * file)
name|ngx_open_file_del_event
parameter_list|(
name|ngx_cached_open_file_t
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|event
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|ngx_del_event
argument_list|(
name|file
operator|->
name|event
argument_list|,
name|NGX_VNODE_EVENT
argument_list|,
name|file
operator|->
name|count
condition|?
name|NGX_FLUSH_EVENT
else|:
name|NGX_CLOSE_EVENT
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
operator|->
name|event
operator|->
name|data
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
operator|->
name|event
argument_list|)
expr_stmt|;
name|file
operator|->
name|event
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|use_event
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_expire_old_cached_files (ngx_open_file_cache_t * cache,ngx_uint_t n,ngx_log_t * log)
name|ngx_expire_old_cached_files
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_uint_t
name|n
parameter_list|,
name|ngx_log_t
modifier|*
name|log
parameter_list|)
block|{
name|time_t
name|now
decl_stmt|;
name|ngx_queue_t
modifier|*
name|q
decl_stmt|;
name|ngx_cached_open_file_t
modifier|*
name|file
decl_stmt|;
name|now
operator|=
name|ngx_time
argument_list|()
expr_stmt|;
comment|/*      * n == 1 deletes one or two inactive files      * n == 0 deletes least recently used file by force      *        and one or two inactive files      */
while|while
condition|(
name|n
operator|<
literal|3
condition|)
block|{
if|if
condition|(
name|ngx_queue_empty
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|)
condition|)
block|{
return|return;
block|}
name|q
operator|=
name|ngx_queue_last
argument_list|(
operator|&
name|cache
operator|->
name|expire_queue
argument_list|)
expr_stmt|;
name|file
operator|=
name|ngx_queue_data
argument_list|(
name|q
argument_list|,
name|ngx_cached_open_file_t
argument_list|,
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|++
operator|!=
literal|0
operator|&&
name|now
operator|-
name|file
operator|->
name|accessed
operator|<=
name|cache
operator|->
name|inactive
condition|)
block|{
return|return;
block|}
name|ngx_queue_remove
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ngx_rbtree_delete
argument_list|(
operator|&
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|file
operator|->
name|node
argument_list|)
expr_stmt|;
name|cache
operator|->
name|current
operator|--
expr_stmt|;
name|ngx_log_debug1
argument_list|(
name|NGX_LOG_DEBUG_CORE
argument_list|,
name|log
argument_list|,
literal|0
argument_list|,
literal|"expire cached open file: %s"
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|err
operator|&&
operator|!
name|file
operator|->
name|is_dir
condition|)
block|{
name|file
operator|->
name|close
operator|=
literal|1
expr_stmt|;
name|ngx_close_cached_file
argument_list|(
name|cache
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ngx_free
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_open_file_cache_rbtree_insert_value (ngx_rbtree_node_t * temp,ngx_rbtree_node_t * node,ngx_rbtree_node_t * sentinel)
name|ngx_open_file_cache_rbtree_insert_value
parameter_list|(
name|ngx_rbtree_node_t
modifier|*
name|temp
parameter_list|,
name|ngx_rbtree_node_t
modifier|*
name|node
parameter_list|,
name|ngx_rbtree_node_t
modifier|*
name|sentinel
parameter_list|)
block|{
name|ngx_rbtree_node_t
modifier|*
modifier|*
name|p
decl_stmt|;
name|ngx_cached_open_file_t
modifier|*
name|file
decl_stmt|,
modifier|*
name|file_temp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|node
operator|->
name|key
operator|<
name|temp
operator|->
name|key
condition|)
block|{
name|p
operator|=
operator|&
name|temp
operator|->
name|left
expr_stmt|;
block|}
if|else if
condition|(
name|node
operator|->
name|key
operator|>
name|temp
operator|->
name|key
condition|)
block|{
name|p
operator|=
operator|&
name|temp
operator|->
name|right
expr_stmt|;
block|}
else|else
block|{
comment|/* node->key == temp->key */
name|file
operator|=
operator|(
name|ngx_cached_open_file_t
operator|*
operator|)
name|node
expr_stmt|;
name|file_temp
operator|=
operator|(
name|ngx_cached_open_file_t
operator|*
operator|)
name|temp
expr_stmt|;
name|p
operator|=
operator|(
name|ngx_strcmp
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|file_temp
operator|->
name|name
argument_list|)
operator|<
literal|0
operator|)
condition|?
operator|&
name|temp
operator|->
name|left
else|:
operator|&
name|temp
operator|->
name|right
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|sentinel
condition|)
block|{
break|break;
block|}
name|temp
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|temp
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|sentinel
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|sentinel
expr_stmt|;
name|ngx_rbt_red
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ngx_cached_open_file_t
modifier|*
DECL|function|ngx_open_file_lookup (ngx_open_file_cache_t * cache,ngx_str_t * name,uint32_t hash)
name|ngx_open_file_lookup
parameter_list|(
name|ngx_open_file_cache_t
modifier|*
name|cache
parameter_list|,
name|ngx_str_t
modifier|*
name|name
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|ngx_int_t
name|rc
decl_stmt|;
name|ngx_rbtree_node_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|sentinel
decl_stmt|;
name|ngx_cached_open_file_t
modifier|*
name|file
decl_stmt|;
name|node
operator|=
name|cache
operator|->
name|rbtree
operator|.
name|root
expr_stmt|;
name|sentinel
operator|=
name|cache
operator|->
name|rbtree
operator|.
name|sentinel
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|sentinel
condition|)
block|{
if|if
condition|(
name|hash
operator|<
name|node
operator|->
name|key
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|left
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|hash
operator|>
name|node
operator|->
name|key
condition|)
block|{
name|node
operator|=
name|node
operator|->
name|right
expr_stmt|;
continue|continue;
block|}
comment|/* hash == node->key */
name|file
operator|=
operator|(
name|ngx_cached_open_file_t
operator|*
operator|)
name|node
expr_stmt|;
name|rc
operator|=
name|ngx_strcmp
argument_list|(
name|name
operator|->
name|data
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
return|return
name|file
return|;
block|}
name|node
operator|=
operator|(
name|rc
operator|<
literal|0
operator|)
condition|?
name|node
operator|->
name|left
else|:
name|node
operator|->
name|right
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
DECL|function|ngx_open_file_cache_remove (ngx_event_t * ev)
name|ngx_open_file_cache_remove
parameter_list|(
name|ngx_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|ngx_cached_open_file_t
modifier|*
name|file
decl_stmt|;
name|ngx_open_file_cache_event_t
modifier|*
name|fev
decl_stmt|;
name|fev
operator|=
name|ev
operator|->
name|data
expr_stmt|;
name|file
operator|=
name|fev
operator|->
name|file
expr_stmt|;
name|ngx_queue_remove
argument_list|(
operator|&
name|file
operator|->
name|queue
argument_list|)
expr_stmt|;
name|ngx_rbtree_delete
argument_list|(
operator|&
name|fev
operator|->
name|cache
operator|->
name|rbtree
argument_list|,
operator|&
name|file
operator|->
name|node
argument_list|)
expr_stmt|;
name|fev
operator|->
name|cache
operator|->
name|current
operator|--
expr_stmt|;
comment|/* NGX_ONESHOT_EVENT was already deleted */
name|file
operator|->
name|event
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|use_event
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|close
operator|=
literal|1
expr_stmt|;
name|ngx_close_cached_file
argument_list|(
name|fev
operator|->
name|cache
argument_list|,
name|file
argument_list|,
literal|0
argument_list|,
name|ev
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* free memory only when fev->cache and fev->file are already not needed */
name|ngx_free
argument_list|(
name|ev
operator|->
name|data
argument_list|)
expr_stmt|;
name|ngx_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

